👉 [English version (README.md)](./README.md)

> ⚠️ 注意！このプロジェクトは現在開発中であり、アーキテクチャが大幅に変更される可能性があります。  
> ご利用は自己責任でお願いします（あるいは、安定するまで使用しないでください）。

# Docodemo.Async.Tasks

## ✨ 概要

`Task` ベースのメソッド群を構成・実行・結果収集するための **fluent API** を提供します。  
実現を目指す機能は [AsyncBridge](https://tejacques.github.io/AsyncBridge/) に似ていますが、現時点ではまだ開発初期段階です。

---

## 📦 機能

- `Task`（`Task<T>` を含む）の集合と、実行完了時のコールバックを構成できます。
  - `CancellationToken` によるキャンセル制御をサポート

- タスク集合は同期コンテキスト上から実行できます。
  - ブロッキング実行／非ブロッキング実行の選択が可能

- 結果は、コールバックまたは戻り値として受け取れます。
  - 発生した例外も集約されて通知
  - コールバックは同期／非同期メソッドいずれも使用可能

- 今後の拡張予定（夢も含まれます）：
  - タスクのタイムアウト指定
  - ワーカースレッドの有無・上限数の制御（現在は同期スレッドで実行）
  - Continuation に使用する同期コンテキストの明示的制御（現状は `SynchronizationContext.Current` とは無関係）
  - デバッグ用の Verbose モード（ログやタスクのトレース）
  - もし可能なら……デッドロック検出とか？笑

---

## 🚀 使用例

```csharp
// Coming soon...

```

## 💡モチベーション

C# 5.0 で `async` / `await` が導入されて以降、非同期処理は .NET におけるアプリケーション開発（とくに ASP.NET や GUI アプリケーション）にとって必要不可欠なものとなりました。

そしてこれからの時代、生成AIのような外部処理やクラウド連携の増加により、「待つ」ことの重要性はさらに高まっていくと考えられます。
生成AIの応答速度は、純粋なコンピュータ処理と比べて「桁違いに遅く」、アプリケーション側が適切に待つ設計をできるかどうかが、UXや性能に直結する場面が増えてきました。

しかし現状、`async` / `await` を活かした設計に使える「ソフトウェア部品」は、意外と発展が遅れています。
特に「同期と非同期の橋渡し」部分── `Task.Wait()` や `GetAwaiter().GetResult()` のような低レベルAPI──は、初学者にとって取っつきにくく、また開発チームごとにそれを利用するための文化の差も大きいのが現実です。

また、「待つ」ことも含めたテスト自動化や CI/CD においても、表面的な回避ではなく、非同期処理を正しく扱うためのツールが必要だと感じています。

そこでこのライブラリでは、非同期処理を“扉（Door）”として扱う発想で、非同期・同期の世界を安全かつ柔軟に橋渡しすることを目指します。
ナウく、そして人類の進歩に少しでも貢献できる形で。

それが、**Docodemo.Async.Tasks** のミッションです。

## 🗃️ Nupkg

現在基本機能を開発中であり、Nupkg はまだ公開していません。公開まで（期待せずに）しばらくお待ちください。

## 📜 ライセンス
Apache License 2.0